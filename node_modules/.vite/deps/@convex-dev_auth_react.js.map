{
  "version": 3,
  "sources": ["../../@convex-dev/auth/dist/react/index.js", "../../@convex-dev/auth/dist/react/client.js"],
  "sourcesContent": ["/**\n * React bindings for Convex Auth.\n *\n * @module\n */\n\"use client\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { ConvexHttpClient } from \"convex/browser\";\nimport { ConvexProviderWithAuth } from \"convex/react\";\nimport { useContext, useMemo } from \"react\";\nimport { AuthProvider, ConvexAuthActionsContext, ConvexAuthTokenContext, useAuth, } from \"./client.js\";\n/**\n * Use this hook to access the `signIn` and `signOut` methods:\n *\n * ```ts\n * import { useAuthActions } from \"@convex-dev/auth/react\";\n *\n * function SomeComponent() {\n *   const { signIn, signOut } = useAuthActions();\n *   // ...\n * }\n * ```\n */\nexport function useAuthActions() {\n    return useContext(ConvexAuthActionsContext);\n}\n/**\n * Replace your `ConvexProvider` with this component to enable authentication.\n *\n * ```tsx\n * import { ConvexAuthProvider } from \"@convex-dev/auth/react\";\n * import { ConvexReactClient } from \"convex/react\";\n * import { ReactNode } from \"react\";\n *\n * const convex = new ConvexReactClient(/* ... *\\/);\n *\n * function RootComponent({ children }: { children: ReactNode }) {\n *   return <ConvexAuthProvider client={convex}>{children}</ConvexAuthProvider>;\n * }\n * ```\n */\nexport function ConvexAuthProvider(props) {\n    const { client, storage, storageNamespace, replaceURL, children } = props;\n    const authClient = useMemo(() => ({\n        authenticatedCall(action, args) {\n            return client.action(action, args);\n        },\n        unauthenticatedCall(action, args) {\n            return new ConvexHttpClient(client.address).action(action, args);\n        },\n        verbose: client.options?.verbose,\n    }), [client]);\n    return (_jsx(AuthProvider, { client: authClient, storage: storage ??\n            // Handle SSR, RN, Web, etc.\n            // Pretend we always have storage, the component checks\n            // it in first useEffect.\n            (typeof window === \"undefined\" ? undefined : window?.localStorage), storageNamespace: storageNamespace ?? client.address, replaceURL: replaceURL ??\n            ((url) => {\n                window.history.replaceState({}, \"\", url);\n            }), children: _jsx(ConvexProviderWithAuth, { client: client, useAuth: useAuth, children: children }) }));\n}\n/**\n * Use this hook to access the JWT token on the client, for authenticating\n * your Convex HTTP actions.\n *\n * You should not pass this token to other servers (think of it\n * as an \"ID token\").\n *\n * ```ts\n * import { useAuthToken } from \"@convex-dev/auth/react\";\n *\n * function SomeComponent() {\n *   const token = useAuthToken();\n *   const onClick = async () => {\n *     await fetch(`${CONVEX_SITE_URL}/someEndpoint`, {\n *       headers: {\n *         Authorization: `Bearer ${token}`,\n *       },\n *     });\n *   };\n *   // ...\n * }\n * ```\n */\nexport function useAuthToken() {\n    return useContext(ConvexAuthTokenContext);\n}\n", "import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState, } from \"react\";\nexport const ConvexAuthActionsContext = createContext(undefined);\nconst ConvexAuthInternalContext = createContext(undefined);\nexport function useAuth() {\n    return useContext(ConvexAuthInternalContext);\n}\nexport const ConvexAuthTokenContext = createContext(null);\nconst VERIFIER_STORAGE_KEY = \"__convexAuthOAuthVerifier\";\nconst JWT_STORAGE_KEY = \"__convexAuthJWT\";\nconst REFRESH_TOKEN_STORAGE_KEY = \"__convexAuthRefreshToken\";\nconst SERVER_STATE_FETCH_TIME_STORAGE_KEY = \"__convexAuthServerStateFetchTime\";\nexport function AuthProvider({ client, serverState, onChange, storage, storageNamespace, replaceURL, children, }) {\n    const token = useRef(serverState?._state.token ?? null);\n    const [isLoading, setIsLoading] = useState(token.current === null);\n    const [tokenState, setTokenState] = useState(token.current);\n    const verbose = client.verbose ?? false;\n    const logVerbose = useCallback((message) => {\n        if (verbose) {\n            console.debug(`${new Date().toISOString()} ${message}`);\n        }\n    }, [verbose]);\n    const { storageSet, storageGet, storageRemove, storageKey } = useNamespacedStorage(storage, storageNamespace);\n    const [isRefreshingToken, setIsRefreshingToken] = useState(false);\n    const setToken = useCallback(async (args) => {\n        const wasAuthenticated = token.current !== null;\n        let newToken;\n        if (args.tokens === null) {\n            token.current = null;\n            if (args.shouldStore) {\n                await storageRemove(JWT_STORAGE_KEY);\n                await storageRemove(REFRESH_TOKEN_STORAGE_KEY);\n            }\n            newToken = null;\n        }\n        else {\n            const { token: value } = args.tokens;\n            token.current = value;\n            if (args.shouldStore) {\n                const { refreshToken } = args.tokens;\n                await storageSet(JWT_STORAGE_KEY, value);\n                await storageSet(REFRESH_TOKEN_STORAGE_KEY, refreshToken);\n            }\n            newToken = value;\n        }\n        if (wasAuthenticated !== (newToken !== null)) {\n            await onChange?.();\n        }\n        setTokenState(newToken);\n        setIsLoading(false);\n    }, [storageSet, storageRemove]);\n    useEffect(() => {\n        const listener = async (e) => {\n            if (isRefreshingToken) {\n                // There are 3 different ways to trigger this pop up so just try all of\n                // them.\n                e.preventDefault();\n                // This confirmation message doesn't actually appear in most modern\n                // browsers but we tried.\n                const confirmationMessage = \"Are you sure you want to leave? Your changes may not be saved.\";\n                e.returnValue = true;\n                return confirmationMessage;\n            }\n        };\n        browserAddEventListener(\"beforeunload\", listener);\n        return () => {\n            browserRemoveEventListener(\"beforeunload\", listener);\n        };\n    });\n    useEffect(() => {\n        // We're listening for:\n        // 1. sibling tabs in case of localStorage\n        // 2. other frames in case of sessionStorage\n        const listener = (event) => {\n            void (async () => {\n                // TODO: Test this if statement works in iframes correctly\n                if (event.storageArea !== storage) {\n                    return;\n                }\n                // Another tab/frame set the access token, use it\n                if (event.key === storageKey(JWT_STORAGE_KEY)) {\n                    const value = event.newValue;\n                    logVerbose(`synced access token, is null: ${value === null}`);\n                    // We don't write into storage since the event came from there and\n                    // we'd trigger a loop, plus we get each key as a separate event so\n                    // we don't have the refresh key here.\n                    await setToken({\n                        shouldStore: false,\n                        tokens: value === null ? null : { token: value },\n                    });\n                }\n            })();\n        };\n        browserAddEventListener(\"storage\", listener);\n        return () => browserRemoveEventListener(\"storage\", listener);\n    }, [setToken]);\n    const verifyCodeAndSetToken = useCallback(async (args) => {\n        const { tokens } = await client.unauthenticatedCall(\"auth:signIn\", \"code\" in args\n            ? { params: { code: args.code }, verifier: args.verifier }\n            : args);\n        logVerbose(`retrieved tokens, is null: ${tokens === null}`);\n        await setToken({ shouldStore: true, tokens: tokens ?? null });\n        return tokens !== null;\n    }, [client, setToken]);\n    const signIn = useCallback(async (provider, args) => {\n        const params = args instanceof FormData\n            ? Array.from(args.entries()).reduce((acc, [key, value]) => {\n                acc[key] = value;\n                return acc;\n            }, {})\n            : args ?? {};\n        const verifier = (await storageGet(VERIFIER_STORAGE_KEY)) ?? undefined;\n        await storageRemove(VERIFIER_STORAGE_KEY);\n        const result = await client.authenticatedCall(\"auth:signIn\", { provider, params, verifier });\n        if (result.redirect !== undefined) {\n            const url = new URL(result.redirect);\n            await storageSet(VERIFIER_STORAGE_KEY, result.verifier);\n            // Do not redirect in React Native\n            if (window.location !== undefined) {\n                window.location.href = url.toString();\n            }\n            return { signingIn: false, redirect: url };\n        }\n        else if (result.tokens !== undefined) {\n            const { tokens } = result;\n            logVerbose(`signed in and got tokens, is null: ${tokens === null}`);\n            await setToken({ shouldStore: true, tokens });\n            return { signingIn: result.tokens !== null };\n        }\n        return { signingIn: false };\n    }, [client, setToken, storageGet]);\n    const signOut = useCallback(async () => {\n        try {\n            await client.authenticatedCall(\"auth:signOut\");\n        }\n        catch (error) {\n            // Ignore any errors, they are usually caused by being\n            // already signed out, which is ok.\n        }\n        logVerbose(`signed out, erasing tokens`);\n        await setToken({ shouldStore: true, tokens: null });\n    }, [setToken, client]);\n    const fetchAccessToken = useCallback(async ({ forceRefreshToken }) => {\n        if (forceRefreshToken) {\n            const tokenBeforeLockAquisition = token.current;\n            return await browserMutex(REFRESH_TOKEN_STORAGE_KEY, async () => {\n                const tokenAfterLockAquisition = token.current;\n                // Another tab or frame just refreshed the token, we can use it\n                // and skip another refresh.\n                if (tokenAfterLockAquisition !== tokenBeforeLockAquisition) {\n                    logVerbose(`returning synced token, is null: ${tokenAfterLockAquisition === null}`);\n                    return tokenAfterLockAquisition;\n                }\n                const refreshToken = (await storageGet(REFRESH_TOKEN_STORAGE_KEY)) ?? null;\n                if (refreshToken !== null) {\n                    setIsRefreshingToken(true);\n                    await storageRemove(REFRESH_TOKEN_STORAGE_KEY);\n                    await verifyCodeAndSetToken({ refreshToken }).finally(() => {\n                        setIsRefreshingToken(false);\n                    });\n                    logVerbose(`returning retrieved token, is null: ${tokenAfterLockAquisition === null}`);\n                    return token.current;\n                }\n                else {\n                    setIsRefreshingToken(false);\n                    logVerbose(`returning null, there is no refresh token`);\n                    return null;\n                }\n            });\n        }\n        return token.current;\n    }, [verifyCodeAndSetToken, signOut, storageGet]);\n    const signingInWithCodeFromURL = useRef(false);\n    useEffect(() => {\n        // Has to happen in useEffect to avoid SSR.\n        if (storage === undefined) {\n            throw new Error(\"`localStorage` is not available in this environment, \" +\n                \"set the `storage` prop on `ConvexAuthProvider`!\");\n        }\n        const readStateFromStorage = async () => {\n            const token = (await storageGet(JWT_STORAGE_KEY)) ?? null;\n            logVerbose(`retrieved token from storage, is null: ${token === null}`);\n            await setToken({\n                shouldStore: false,\n                tokens: token === null ? null : { token },\n            });\n        };\n        if (serverState !== undefined) {\n            // First check that this isn't a subsequent render\n            // with stale serverState.\n            const timeFetched = storageGet(SERVER_STATE_FETCH_TIME_STORAGE_KEY);\n            const setTokensFromServerState = (timeFetched) => {\n                if (!timeFetched || serverState._timeFetched > +timeFetched) {\n                    const { token, refreshToken } = serverState._state;\n                    const tokens = token === null || refreshToken === null\n                        ? null\n                        : { token, refreshToken };\n                    void storageSet(SERVER_STATE_FETCH_TIME_STORAGE_KEY, serverState._timeFetched.toString());\n                    void setToken({ tokens, shouldStore: true });\n                }\n                else {\n                    void readStateFromStorage();\n                }\n            };\n            // We want to avoid async if possible.\n            if (timeFetched instanceof Promise) {\n                void timeFetched.then(setTokensFromServerState);\n            }\n            else {\n                setTokensFromServerState(timeFetched);\n            }\n            return;\n        }\n        const code = typeof window?.location !== \"undefined\"\n            ? new URLSearchParams(window.location.search).get(\"code\")\n            : null;\n        // code from URL is only consumed initially,\n        // ref avoids racing in Strict mode\n        if (signingInWithCodeFromURL.current || code) {\n            if (code && !signingInWithCodeFromURL.current) {\n                signingInWithCodeFromURL.current = true;\n                const url = new URL(window.location.href);\n                url.searchParams.delete(\"code\");\n                void (async () => {\n                    await replaceURL(url.pathname + url.search + url.hash);\n                    await signIn(undefined, { code });\n                    signingInWithCodeFromURL.current = false;\n                })();\n            }\n        }\n        else {\n            void readStateFromStorage();\n        }\n    }, \n    // Explicitly chosen dependencies.\n    // This effect should mostly only run once\n    // on mount.\n    [client, storageGet]);\n    const actions = useMemo(() => ({ signIn, signOut }), [signIn, signOut]);\n    const isAuthenticated = tokenState !== null;\n    const authState = useMemo(() => ({\n        isLoading,\n        isAuthenticated,\n        fetchAccessToken,\n    }), [fetchAccessToken, isLoading, isAuthenticated]);\n    return (_jsx(ConvexAuthInternalContext.Provider, { value: authState, children: _jsx(ConvexAuthActionsContext.Provider, { value: actions, children: _jsx(ConvexAuthTokenContext.Provider, { value: tokenState, children: children }) }) }));\n}\nfunction useNamespacedStorage(peristentStorage, namespace) {\n    const inMemoryStorage = useInMemoryStorage();\n    const storage = useMemo(() => peristentStorage ?? inMemoryStorage(), [peristentStorage]);\n    const escapedNamespace = namespace.replace(/[^a-zA-Z0-9]/g, \"\");\n    const storageKey = useCallback((key) => `${key}_${escapedNamespace}`, [namespace]);\n    const storageSet = useCallback((key, value) => storage.setItem(storageKey(key), value), [storage, storageKey]);\n    const storageGet = useCallback((key) => storage.getItem(storageKey(key)), [storage, storageKey]);\n    const storageRemove = useCallback((key) => storage.removeItem(storageKey(key)), [storage, storageKey]);\n    return { storageSet, storageGet, storageRemove, storageKey };\n}\nfunction useInMemoryStorage() {\n    const [inMemoryStorage, setInMemoryStorage] = useState({});\n    return () => ({\n        getItem: (key) => inMemoryStorage[key],\n        setItem: (key, value) => {\n            setInMemoryStorage((prev) => ({ ...prev, [key]: value }));\n        },\n        removeItem: (key) => {\n            setInMemoryStorage((prev) => {\n                const { [key]: _, ...rest } = prev;\n                return rest;\n            });\n        },\n    });\n}\n// In the browser, executes the callback as the only tab / frame at a time.\nasync function browserMutex(key, callback) {\n    const lockManager = window?.navigator?.locks;\n    return lockManager !== undefined\n        ? await lockManager.request(key, callback)\n        : await manualMutex(key, callback);\n}\nfunction getMutexValue(key) {\n    if (globalThis.__convexAuthMutexes === undefined) {\n        globalThis.__convexAuthMutexes = {};\n    }\n    let mutex = globalThis.__convexAuthMutexes[key];\n    if (mutex === undefined) {\n        globalThis.__convexAuthMutexes[key] = {\n            currentlyRunning: null,\n            waiting: [],\n        };\n    }\n    mutex = globalThis.__convexAuthMutexes[key];\n    return mutex;\n}\nfunction setMutexValue(key, value) {\n    globalThis.__convexAuthMutexes[key] = value;\n}\nasync function enqueueCallbackForMutex(key, callback) {\n    const mutex = getMutexValue(key);\n    if (mutex.currentlyRunning === null) {\n        setMutexValue(key, {\n            currentlyRunning: callback().finally(() => {\n                const nextCb = getMutexValue(key).waiting.shift();\n                setMutexValue(key, {\n                    ...getMutexValue(key),\n                    currentlyRunning: nextCb === undefined ? null : enqueueCallbackForMutex(key, nextCb),\n                });\n            }),\n            waiting: [],\n        });\n    }\n    else {\n        setMutexValue(key, {\n            ...mutex,\n            waiting: [...mutex.waiting, callback],\n        });\n    }\n}\nasync function manualMutex(key, callback) {\n    const outerPromise = new Promise((resolve, reject) => {\n        const wrappedCallback = () => {\n            return callback()\n                .then((v) => resolve(v))\n                .catch((e) => reject(e));\n        };\n        void enqueueCallbackForMutex(key, wrappedCallback);\n    });\n    return outerPromise;\n}\nfunction browserAddEventListener(type, listener, options) {\n    window.addEventListener?.(type, listener, options);\n}\nfunction browserRemoveEventListener(type, listener, options) {\n    window.removeEventListener?.(type, listener, options);\n}\n"],
  "mappings": "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",
  "names": ["import_dist", "import_jsx_runtime", "import_react", "import_dist", "token", "timeFetched", "_jsx", "_jsx"]
}
